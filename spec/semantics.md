# 语义规则

本文档定义 Zero 语言的语义规则、求值顺序和边界行为。

---

## 类型检查

### 编译时类型检查

所有类型检查在编译时进行：

- 变量赋值类型检查
- 运算符操作数类型检查
- 函数参数类型检查
- 返回值类型检查

### 严格类型匹配

Zero 要求类型严格匹配，不支持隐式类型转换：

```zero
let x = 10 + 20;        // 正确：Integer + Integer
let y = 3.14 + 2.71;    // 正确：Float + Float

// let z = 10 + 3.14;   // 错误：Integer + Float
// let s = 42 + "hello"; // 错误：Integer + String
```

---

## 求值顺序

### 表达式求值

表达式从左到右求值：

```zero
f() + g() + h()
// 求值顺序：f(), g(), h()，然后依次相加
```

### 函数参数

函数参数从左到右求值：

```zero
func(a(), b(), c())
// 求值顺序：a(), b(), c()，然后调用 func
```

### 赋值表达式

赋值是右结合的，从右到左求值：

```zero
a = b = c = 10
// 等价于：a = (b = (c = 10))
// 求值顺序：c = 10, b = 10, a = 10
```

---

## 短路求值

### 逻辑与 (&&)

如果左操作数为 `false`，则不求值右操作数：

```zero
false && expensive_function()
// expensive_function() 不会被调用

true && expensive_function()
// expensive_function() 会被调用
```

### 逻辑或 (||)

如果左操作数为 `true`，则不求值右操作数：

```zero
true || expensive_function()
// expensive_function() 不会被调用

false || expensive_function()
// expensive_function() 会被调用
```

---

## 算术行为

### 整数运算

**溢出**:

- **TODO**: 当前未定义
- 建议实现者检测溢出并报错
- 未来版本应明确定义为：回绕、饱和或 panic

**除法**:

- 向零截断（truncate towards zero）
- `10 / 3` -> `3`
- `-10 / 3` -> `-3`
- `10 / -3` -> `-3`
- `-10 / -3` -> `3`

**取模**:

- 结果符号与被除数相同
- `10 % 3` -> `1`
- `-10 % 3` -> `-1`
- `10 % -3` -> `1`
- `-10 % -3` -> `-1`

### 浮点运算

**精度**:

- 遵循 IEEE 754 双精度标准
- 浮点运算可能有精度误差

```zero
let x = 0.1 + 0.2;
// x 可能不完全等于 0.3（精度问题）
```

**特殊值**:

- `1.0 / 0.0` -> `+inf`
- `-1.0 / 0.0` -> `-inf`
- **TODO**: NaN 行为未定义

---

## 除零行为

### 整数除零

除以零导致运行时错误，程序终止：

```zero
let x = 10 / 0;   // 运行时错误
let y = 10 % 0;   // 运行时错误
```

**错误信息**: "Division by zero" 或 "Modulo by zero"

### 浮点除零

除以零产生无穷大：

```zero
let x = 10.0 / 0.0;   // +inf
let y = -10.0 / 0.0;  // -inf
```

---

## 变量初始化

### 必须初始化

所有变量必须在声明时初始化：

```zero
// 错误
let x;
var y;

// 正确
let x = 0;
var y = 0;
```

### 使用前声明

变量必须在使用前声明：

```zero
// 错误
let y = x + 10;
let x = 5;

// 正确
let x = 5;
let y = x + 10;
```

---

## 控制流语义

### If 语句

条件表达式必须是 Boolean 类型：

```zero
// 正确
if x > 10 {
    print("large");
}

// 错误
if 10 {           // Integer 不是 Boolean
    print("hello");
}
```

### While 循环

条件在每次迭代前求值：

```zero
var i = 0;
while i < 5 {
    print(i);
    i = i + 1;
}
// 输出：0, 1, 2, 3, 4
```

### For 循环

范围是半开区间 `[start, end)`：

```zero
for i in 0..5 {
    print(i);
}
// 输出：0, 1, 2, 3, 4（不包括 5）
```

**空范围**: 当 `start >= end` 时，循环体不执行：

```zero
for i in 5..5 {
    // 不执行
}

for i in 10..5 {
    // 不执行
}
```

---

## 函数语义

### 参数传递

**值传递**: 参数按值复制：

```zero
fn modify(x) {
    x = x + 1;  // 仅修改局部副本
}

var a = 10;
modify(a);
print(a);  // 输出：10（a 未改变）
```

### 返回语句

`return` 立即退出函数：

```zero
fn func() {
    print("before");
    return;
    print("after");  // 不会执行
}
```

### 递归

支持递归，但无尾调用优化：

```zero
fn factorial(n) {
    if n <= 1 {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
```

**限制**: 深度递归可能导致栈溢出。

---

## 字符串语义

### 不可变

字符串是不可变的：

```zero
let s = "hello";
// 无法修改 s 的内容
```

### 比较

字符串按字典序比较（UTF-8 字节序）：

```zero
"apple" < "banana"  // true
"A" < "a"           // true（ASCII 65 < 97）
"hello" == "hello"  // true
```

---

## 范围语义

### 半开区间

范围 `start..end` 是半开区间 `[start, end)`：

- 包含 `start`
- 不包含 `end`

### 仅用于 For 循环

范围表达式只能在 for 循环中使用：

```zero
// 正确
for i in 0..10 {
    print(i);
}

// 错误
let r = 0..10;  // 不能赋值给变量
```

---

## 作用域语义

### 词法作用域

变量的可见性由代码结构决定（编译时确定）：

```zero
let x = 10;

fn func() {
    print(x);  // 可访问外层变量
}
```

### 变量遮蔽

内层可以遮蔽外层变量：

```zero
let x = 10;
{
    let x = 20;
    print(x);  // 20
}
print(x);      // 10
```

---

## 未定义行为

以下行为当前未定义（标记为 **TODO**）：

1. **整数溢出**: 应定义为回绕、饱和或 panic
2. **NaN 处理**: 浮点 NaN 的比较和运算行为
3. **栈溢出**: 深度递归导致的栈溢出
4. **无返回值函数**: 缺少 return 的函数行为

---

## 错误处理

### 编译时错误

以下情况导致编译错误：

- 类型不匹配
- 使用未声明的变量
- 重复声明（var）
- 语法错误

### 运行时错误

以下情况导致运行时错误（程序终止）：

- 整数除以零
- 整数取模零
- 栈溢出

**TODO**: 未来版本可能添加异常系统或 Result 类型。

---

## 性能保证

### 无垃圾回收暂停

当前版本不使用垃圾回收，无 GC 暂停。

### 栈分配

基本类型（Integer, Float, Boolean）在栈上分配。

### 字符串优化

String 是不可变的，实现可以进行字符串驻留优化。

---

## 实现建议

### 编译器

1. **类型检查**: 在语义分析阶段进行完整的类型检查
2. **常量折叠**: 对常量表达式进行编译时求值
3. **死代码消除**: 移除 return 后的不可达代码

### 运行时

1. **栈大小**: 建议至少 1MB 栈空间
2. **溢出检测**: 建议检测整数溢出
3. **错误报告**: 提供清晰的错误消息和位置信息

---

## 总结

Zero 的语义规则：

- **类型安全**: 编译时类型检查，无隐式转换
- **可预测**: 明确的求值顺序和行为
- **简洁**: 最少的特殊情况
- **安全**: 错误在编译时或运行时被捕获
- **明确**: 未定义的行为明确标记
