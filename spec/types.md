# 类型系统

本文档定义 Zero 语言的类型系统。

---

## 概述

Zero 使用**静态类型系统**和**类型推断**：

- 每个变量和表达式都有确定的类型
- 类型在编译时检查
- 类型通过初始化表达式自动推断
- 不支持隐式类型转换

---

## 基本类型

Zero 支持四种基本类型：

### 1. Integer（整数）

**表示**: 64位有符号整数

**范围**:

```zero
-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
即 -2^63 到 2^63 - 1
```

**字面量**:

```zero
0
42
-100
1000000
```

**内存表示**:

- 采用二进制补码表示
- 占用 8 字节（64 位）

**运算**:

- 支持算术运算：`+`, `-`, `*`, `/`, `%`
- 支持比较运算：`==`, `!=`, `<`, `<=`, `>`, `>=`
- 支持一元负号：`-`

**特殊行为**:

- **溢出**: 未定义行为（**TODO**: 未来应明确定义）
- **除零**: 运行时错误，程序终止
- **取模零**: 运行时错误，程序终止

---

### 2. Float（浮点数）

**表示**: IEEE 754 双精度浮点数（64位）

**精度**: 约 15-17 位十进制有效数字

**范围**:

```zero
±1.7976931348623157 × 10^308 (最大值)
±2.2250738585072014 × 10^-308 (最小正值)
```

**字面量**:

```zero
3.14
-2.5
0.0
100.0
```

**内存表示**:

- 遵循 IEEE 754 双精度格式
- 占用 8 字节（64 位）
- 1 位符号 + 11 位指数 + 52 位尾数

**运算**:

- 支持算术运算：`+`, `-`, `*`, `/`（不支持 `%`）
- 支持比较运算：`==`, `!=`, `<`, `<=`, `>`, `>=`
- 支持一元负号：`-`

**特殊值**:

- **正无穷**: `+inf`（除以零时产生）
- **负无穷**: `-inf`
- **NaN**: Not a Number（**TODO**: 当前版本行为未定义）

**精度问题**:

```zero
// 浮点数精度限制
let a = 0.1 + 0.2;  // 可能不等于 0.3
```

---

### 3. String（字符串）

**表示**: UTF-8 编码的字符序列

**可变性**: 不可变（immutable）

**编码**: UTF-8

**字面量**:

```zero
"Hello"
"Zero Language"
""                 // 空字符串
"Line1\nLine2"     // 带换行
"He said \"Hi\""   // 带引号
```

**长度**:

- 无固定长度限制（取决于可用内存）
- 实现可以设置合理上限

**运算**:

- 支持比较运算：`==`, `!=`, `<`, `<=`, `>`, `>=`
- 比较使用字典序（按 UTF-8 字节序）

**字符串比较**:

```zero
"apple" < "banana"     // true（字典序）
"hello" == "hello"     // true
"A" < "a"              // true（ASCII 值 65 < 97）
```

**TODO**: 未来版本可能支持：

- 字符串连接运算符 `+`
- 字符串长度函数
- 子字符串操作
- 字符串插值

---

### 4. Boolean（布尔）

**表示**: 逻辑真值

**值**: `true` 或 `false`

**字面量**:

```zero
true
false
```

**内存表示**:

- 通常占用 1 字节
- 只有两个有效值

**运算**:

- 支持逻辑运算：`&&`, `||`, `!`
- 支持比较运算：`==`, `!=`

**类型转换**:

- 不支持从其他类型隐式转换为布尔
- 条件表达式必须是布尔类型

---

## 类型推断

Zero 使用**静态类型推断**系统。变量的类型在声明时根据初始化表达式自动推断。

### 推断规则

```zero
let x = 42;        // 推断为 Integer
let y = 3.14;      // 推断为 Float
let s = "hello";   // 推断为 String
let b = true;      // 推断为 Boolean
```

### 表达式类型推断

```zero
let sum = 10 + 20;           // Integer
let product = 3.14 * 2.0;    // Float
let is_equal = x == y;       // Boolean
let name = "Hello";          // String
```

### 函数类型推断

函数的参数和返回值类型通过使用位置推断：

```zero
fn add(a, b) {
    return a + b;
}

// 调用
let result = add(10, 20);    // a, b, result 都推断为 Integer
```

---

## 类型兼容性

### 严格类型匹配

Zero 要求类型严格匹配，不支持隐式类型转换：

```zero
let x = 42;
let y = 3.14;

// 错误：类型不匹配
let z = x + y;           // Integer + Float

// 错误：不能将 String 赋给 Integer 变量
var a = 10;
a = "hello";
```

### 相同类型运算

二元运算符要求两个操作数类型相同：

```zero
// 正确
let a = 10 + 20;         // Integer + Integer
let b = 3.14 + 2.71;     // Float + Float

// 错误
let c = 10 + 3.14;       // Integer + Float（类型不匹配）
let d = "hello" + 42;    // String + Integer（类型不匹配）
```

---

## 类型转换

当前版本**不支持类型转换**。

**TODO**: 未来版本可能添加显式类型转换函数：

```zero
// 未来可能的语法
let x = 42;
let y = to_float(x);     // Integer -> Float
let s = to_string(x);    // Integer -> String
```

---

## 类型相关规则

### 变量类型不可变

变量的类型在声明后不能改变：

```zero
let x = 42;
// x = 3.14;      // 错误：类型不匹配

var y = 10;
y = 20;           // 正确：相同类型
// y = "hello";   // 错误：类型不匹配
```

### 必须初始化

所有变量必须在声明时初始化，以便推断类型：

```zero
// 错误：缺少初始化
let x;
var y;

// 正确
let x = 0;
var y = 0;
```

### 函数参数类型

函数参数的类型通过实际调用推断：

```zero
fn square(x) {
    return x * x;
}

// 第一次调用推断类型
let a = square(5);      // x 推断为 Integer
let b = square(3.14);   // x 推断为 Float（如果支持重载）
```

**注意**: 当前版本不支持函数重载，同一函数只能有一种参数类型。

---

## Range 类型

Range 是一种特殊的内部类型，仅用于 `for` 循环：

```zero
for i in 0..10 {
    // 0..10 是 Range 类型
}
```

**特性**:

- 不能赋值给变量
- 只能在 `for` 循环的 `in` 子句中使用
- 表示半开区间 `[start, end)`

---

## 类型检查

### 编译时检查

所有类型检查在编译时进行：

- 变量赋值类型检查
- 运算符操作数类型检查
- 函数参数类型检查
- 返回值类型检查

### 类型错误

类型不匹配会导致编译错误：

```zero
let x = 42;
x = "hello";              // 编译错误：类型不匹配

let y = 10 + "20";        // 编译错误：Integer + String

fn add(a, b) {
    return a + b;
}
add(10, "hello");         // 编译错误：参数类型不匹配
```

---

## 类型系统设计原则

1. **安全性**: 类型错误在编译时捕获
2. **简洁性**: 类型推断减少样板代码
3. **明确性**: 类型行为清晰可预测
4. **限制性**: 不支持隐式转换，避免意外行为

---

## 类型总结表

| 类型 | 大小 | 范围/精度 | 字面量示例 | 可变性 |
|------|------|-----------|------------|--------|
| Integer | 8 字节 | -2^63 到 2^63-1 | `42`, `-100` | 值类型 |
| Float | 8 字节 | IEEE 754 双精度 | `3.14`, `-2.5` | 值类型 |
| String | 可变 | UTF-8 序列 | `"hello"` | 不可变 |
| Boolean | 1 字节 | true/false | `true`, `false` | 值类型 |
| Range | 内部 | Integer 范围 | `0..10` | 内部使用 |

---

## TODO 列表

未来版本计划的类型系统增强：

- [ ] 显式类型转换函数
- [ ] 数组类型
- [ ] 元组类型
- [ ] 结构体（struct）
- [ ] 枚举（enum）
- [ ] 泛型（generics）
- [ ] 类型别名（type alias）
- [ ] 引用类型
- [ ] 可选类型（Optional）
